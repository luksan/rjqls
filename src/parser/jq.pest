WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

program = { SOI ~  pratt_expr ~ ("," ~ pratt_expr)* ~ EOI }

// func_def is a prefix in pratt_expr
func_def = {
    "def" ~ ident ~
    ( "(" ~ (ident | variable) ~ (";" ~ (ident | variable))*  ~ ")" )?
    ~ ":" ~ pratt_expr ~ ";"
}

jq_module = { SOI ~ (func_def | module_directive)* ~ EOI }
module_directive = {"module" ~ pratt_expr ~ ";"}

/// Everything below is for pratt parsing of filter expressions

plusminus = _{"+" | "-" }

number = @{ "-"? ~ ASCII_DIGIT+ ~ ( "." ~ ASCII_DIGIT*)? ~ ( ("e"|"E") ~ plusminus? ~ ASCII_DIGIT+)? }

string = ${ "\"" ~ (inner_str | str_interp)* ~ "\"" }
inner_str = @{ char+ }
str_interp = { "\\(" ~ pratt_expr ~ ")" }

null = { "null" }
bool = { "true" | "false" }
literal = { number | bool | null } // string is parsed separately

ident = ${ !(keywords ~ !( ASCII_ALPHANUMERIC | "_")) ~  (ASCII_ALPHA|"_") ~ ( ASCII_ALPHANUMERIC | "_" )* }
keywords = { "and"|"as"|"break"|"catch"|"foreach"|"if"|"then"|"else"|"elif"|"end"|"label"|"or"|"reduce"|"try" }

obj = {
    "{" ~ "}" |
    "{" ~ obj_pair ~ (comma ~ obj_pair)* ~ "}"
}

obj_pair = { obj_key ~ colon ~ obj_val }
obj_key = { ident | string | variable | ("(" ~ pratt_expr ~ ")") }
obj_val = { primary ~ postfix * | "(" ~ pratt_expr ~ ")" }
arr = {"[" ~ pratt_expr? ~ "]"}
colon = { ":" }

variable = ${ "$" ~ ident }
// the binding is only used to reject invalid bindings, not to actually capture
variable_binding = { variable | ("[" ~ (variable_binding ~ ","?)+ ~ "]")  | ("{" ~ (ident | string) ~ ":" ~ variable_binding ~ "}") }

pratt_prog = { SOI ~ pratt_expr ~ EOI }
pratt_expr = { prefix* ~ primary ~ postfix* ~ (infix ~ prefix* ~ primary ~ postfix* )* }
  infix = _{ arith_assign | upd_assign| alt | and | or | ord | eq | neq | assign|add | sub| mul | div | comma | pipe | as_ }
    alt = {"//"}
    eq = { "==" }
    neq = { "!=" }
    add = { "+" }
    sub = { "-" }
    mul = { "*" }
    div = { "/" }
    ord = { "<=" | ">=" | "<"| ">"}
    and = {"and"}
    or = {"or"}
    upd_assign = {"|="}
    assign = {"="}
    arith_assign = {"//="|"+="| "-="| "*="| "/="| "%=" }
    comma = { "," }
    pipe = { "|" | &"." } // don't consume the dot, parse it as a primary, it will become a pipe in the ast
    as_ = { "as" ~ &(variable_binding ~ (EOI | "|")) }
  prefix = _{ func_def }
  postfix = _{ iterate | slice | arr_idx | ident_idx | string_idx|try }
    iterate = { "[" ~ "]" }
    slice = { "[" ~ pratt_expr? ~ colon ~ pratt_expr? ~ "]" }
    arr_idx = {"["  ~ pratt_expr ~"]"}
    ident_idx = { ident }
    string_idx = { string }
    try = {"?"}
  primary = _{
    obj |
    if_cond |
    label |
    break_ |
    foreach|
    reduce |
    try_catch|
    not|
    dot_primary |
    call |
    string |
    literal |
    ident_primary |
    var_primary |
    arr |
    primary_group
  }
    dot_primary = { "." }
    call = { ident ~ "(" ~ pratt_expr ~ (";" ~ pratt_expr)* ~ ")" }
    ident_primary = { ident }
    var_primary = { variable }
    primary_group = { "(" ~ pratt_expr ~ ")" }
    if_cond = { "if" ~ pratt_expr ~ "then" ~ pratt_expr ~ elif* ~ else_? ~ "end" }
    elif = {"elif" ~ pratt_expr ~ "then" ~ pratt_expr}
    else_ = {"else" ~ pratt_expr}
    not = {"not"}
    label = {"label" ~ variable}
    break_ = {"break"~ variable}
    foreach = {"foreach" ~ pratt_expr ~"as"~variable ~ "(" ~ pratt_expr~";"~pratt_expr~";"~pratt_expr~")"}
    reduce = {"reduce" ~ pratt_expr ~ "as" ~ variable ~ "(" ~ pratt_expr ~ ";" ~ pratt_expr ~ ")"}
    try_catch = {"try" ~pratt_expr ~ ("catch" ~ pratt_expr)?}


