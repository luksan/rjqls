WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

char = { !("\"" | "\\") ~ ANY  }
escape = { "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

program = _{ SOI ~ (include_directive)* ~ pratt_expr ~ EOI }

include_directive = {"include"  ~ "\"" ~ inner_str ~ "\"" ~ pratt_expr? ~ ";"}
module_directive = {"module" ~ pratt_expr ~ ";"}
// func_def is a prefix in pratt_expr
func_def = {
    "def" ~ ident ~
    ( "(" ~ (ident | variable) ~ (";" ~ (ident | variable))*  ~ ")" )?
    ~ ":" ~ pratt_expr ~ ";"
}

jq_module = { SOI ~ (func_def | module_directive)* ~ EOI }
path_string = ${"\"" ~ inner_str ~ "\""}

included_src = _{ SOI ~ (pratt_expr | func_def*) ~ eoi }
eoi = _{ !ANY } // Silent EOI

/// Everything below is for pratt parsing of filter expressions

plusminus = _{"+" | "-" }

number = @{ "-"? ~ ASCII_DIGIT+ ~ ( "." ~ ASCII_DIGIT*)? ~ ( ("e"|"E") ~ plusminus? ~ ASCII_DIGIT+)? }

string = ${ "\"" ~ (inner_str | str_interp)* ~ "\"" }
inner_str = ${ (char|escape)+ }
str_interp = !{ "\\(" ~ pratt_expr ~ ")" }

null = { "null" }
bool = { "true" | "false" }
literal = { number | bool | null } // string is parsed separately

ident = ${ !(keywords ~ !( ASCII_ALPHANUMERIC | "_")) ~  (ASCII_ALPHA|"_") ~ ( ASCII_ALPHANUMERIC | "_" )* }
keywords = { "and"|"as"|"break"|"catch"|"foreach"|"if"|"then"|"else"|"elif"|"end"|"label"|"or"|"reduce"|"try"|"import"|"include"|"module" }

obj = { "{" ~ (obj_pair ~ ("," ~ obj_pair)*)? ~ "}" }

obj_pair = { obj_key ~ ":" ~ obj_val }
obj_key = { ident | string | variable | ("(" ~ pratt_expr ~ ")") }
obj_val = { primary ~ postfix * | "(" ~ pratt_expr ~ ")" }
arr = {"[" ~ pratt_expr? ~ "]"}

variable = ${ "$" ~ ident }

// used for destructuring variable binding
variable_binding = _{ variable | arr | obj }

pratt_prog = { SOI ~ pratt_expr ~ EOI }
pratt_expr = { prefix* ~ primary ~ postfix* ~ (infix ~ prefix* ~ primary ~ postfix* )* }
  infix = _{ arith_assign | upd_assign| alt | and | or | ord | eq | neq | assign | add | sub| mul | div | mod_ | comma | pipe | as_ }
    alt = {"//"}
    eq = { "==" }
    neq = { "!=" }
    add = { "+" }
    sub = { "-" }
    mul = { "*" }
    div = { "/" }
    mod_ = { "%" }
    ord = { "<=" | ">=" | "<"| ">"}
    and = {"and"}
    or = {"or"}
    upd_assign = {"|="}
    assign = {"="}
    arith_assign = ${ (alt | add | sub | mul | div | mod_ ) ~ "=" }
    comma = { "," }
    pipe = { "|" }
    as_ = { "as" ~  variable_binding ~  "|" }
  prefix = _{ func_def | dbg_brk_pre }
    dbg_brk_pre = { "ยง" }
  postfix = _{ idx_chain+ | try_postfix | dbg_brk_post }
    idx_chain = _{ "."? ~ idx_kinds ~ try_idx? }
    idx_kinds = _{ index | iterate | slice }
    try_idx = _{ idx_chain_pipe ~ idx_chain_dot ~ idx_kinds ~ try_postfix }
    idx_chain_pipe = { "."? ~ &"[" | "." } // synthetic |. between indexing ops
    idx_chain_dot = { &ANY }
    index = { "[" ~ pratt_expr ~ "]" | ident | string }
    iterate = { "[" ~ "]" }
    slice = { "[" ~ (( pratt_expr ~ colon ~ pratt_expr? ) | ( colon ~ pratt_expr )) ~ "]" }
    colon = { ":" }
    try_postfix = { "?"+ }
    dbg_brk_post = { "ยง" }
  primary = _{
    obj |
    if_cond |
    label |
    break_ |
    foreach|
    reduce |
    try_catch|
    dot_primary |
    call |
    string |
    literal |
    ident_primary |
    variable |
    arr |
    primary_group
  }
    dot_primary = { "." }
    call = { ident ~ "(" ~ pratt_expr ~ (";" ~ pratt_expr)* ~ ")" }
    ident_primary = { ident }
    primary_group = { "(" ~ pratt_expr ~ ")" }
    if_cond = { "if" ~ pratt_expr ~ "then" ~ pratt_expr ~ elif* ~ else_? ~ "end" }
    elif = {"elif" ~ pratt_expr ~ "then" ~ pratt_expr}
    else_ = {"else" ~ pratt_expr}
    label = {"label" ~ variable}
    break_ = {"break"~ variable}
    foreach = {"foreach" ~ pratt_expr ~ "as" ~ variable ~ "(" ~ pratt_expr ~ ";" ~ pratt_expr ~ (";" ~ pratt_expr)? ~ ")"}
    reduce = {"reduce" ~ pratt_expr ~ "as" ~ variable ~ "(" ~ pratt_expr ~ ";" ~ pratt_expr ~ ")"}
    try_catch = {"try" ~pratt_expr ~ ("catch" ~ pratt_expr)?}


